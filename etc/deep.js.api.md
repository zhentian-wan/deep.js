## API Report File for "deep.js"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
type Absolute<T extends number | string | bigint> = `${T}` extends `-${infer S}` ? S : `${T}`;

// @public (undocumented)
type All<T extends any[], U extends any = T[0]> = T extends [infer H, ...infer RT] ? Equal<H, U> extends true ? All<RT, U> : false : true;

// @public (undocumented)
type AnyOf<T extends readonly any[]> = T extends [infer F, ...infer RT] ? F extends FalsyValues ? AnyOf<RT> : true : false;

// @public (undocumented)
type AppendArgument<Fn extends (...args: any[]) => void, A> = Fn extends (...args: infer Args) => infer RT ? (...x: [...Args, A]) => RT : never;

// @public (undocumented)
type AppendToObject<T extends Record<PropertyKey, any>, U extends string | number | symbol, V extends any> = MergeObject<T & {
    [Key in U]: V;
}>;

// @public
type Assign<T extends Record<string, unknown>, U> = U extends object[] ? U extends [infer F, ...infer RT] ? Assign<MergeObject<({
    [Key in keyof T as Key extends keyof F ? never : Key]: T[Key];
} & {
    [Key in keyof F]: F[Key];
})>, RT> : T : T;

// @public
export function avg(a: number, b: number, c: number): number;

// @public (undocumented)
type BEM<B extends string, E extends string[], M extends string[]> = M["length"] extends 0 ? `${B}__${E[number]}` : E["length"] extends 0 ? `${B}--${M[number]}` : `${B}__${E[number]}--${M[number]}`;

// Warning: (ae-forgotten-export) The symbol "GetTwice" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type BinaryToDecimal<S extends string, Result extends unknown[] = []> = S extends `${infer First extends number}${infer RT}` ? BinaryToDecimal<RT, [...GetTwice<Result>, ...NumberToArray<First>]> : Result["length"];

// Warning: (ae-forgotten-export) The symbol "ToCamelCase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type CamelCase<S extends string> = ToCamelCase<Lowercase<S>>;

// @public (undocumented)
type Camelize<T> = T extends any[] ? T extends [infer F, ...infer RT] ? [Camelize<F>, ...Camelize<RT>] : [] : {
    [Key in keyof T as Key extends string ? `${CamelizeWord<Key>}` : never]: T[Key] extends object ? Camelize<T[Key]> : T[Key];
};

// @public (undocumented)
type CamelizeWord<S> = S extends `${infer F}_${infer RT}` ? `${F}${CamelizeWord<Capitalize<RT>>}` : S;

// @public
type CapitalizeNestObjectKeys<T> = T extends any[] ? T extends [infer F, ...infer R] ? [CapitalizeNestObjectKeys<F>, ...CapitalizeNestObjectKeys<R>] : [] : T extends object ? {
    [K in keyof T as K extends string ? Capitalize<K> : never]: CapitalizeNestObjectKeys<T[K]>;
} : T;

// @public (undocumented)
type CapitalizeWords<S extends string, Prev extends string = "", ACC extends string = ""> = S extends `${infer First}${infer REST}` ? Uppercase<Prev> extends UpperLetterUnion ? CapitalizeWords<REST, First, `${ACC}${First}`> : CapitalizeWords<REST, First, `${ACC}${Uppercase<First>}`> : ACC;

// @public (undocumented)
type Chunk<T extends any[], U extends number, ACC extends any[] = []> = ACC["length"] extends U ? [ACC, ...Chunk<T, U>] : T extends [infer F, ...infer RT] ? Chunk<RT, U, [...ACC, F]> : ACC["length"] extends 0 ? [] : [ACC];

// @public (undocumented)
type ClassPublicKeys<C> = keyof C;

// @public (undocumented)
type Combinations<T extends string, U = T> = U extends T ? U | `${U}${Combinations<Exclude<T, U>>}` : never;

// @public (undocumented)
type ConcatString<T extends unknown[], U extends string, ACC extends string = ""> = T extends [infer F extends string, ...infer RT] ? ACC extends "" ? ConcatString<RT, U, `${F}`> : ConcatString<RT, U, `${ACC}${U}${F}`> : ACC;

// @public (undocumented)
type ConstructTuple<L extends number, ACC extends unknown[] = []> = L extends 0 ? [] : ACC["length"] extends L ? ACC : ConstructTuple<L, [...ACC, unknown]>;

// @public
export function deepFreeze(obj: {
    [K: string]: Primitive | object;
}): Readonly<{
    [K: string]: object | Primitive;
}>;

// @public (undocumented)
type DeepMutable<T extends Record<PropertyKey, any>> = T extends (...args: any[]) => any ? T : {
    -readonly [K in keyof T]: DeepMutable<T[K]>;
};

// Warning: (ae-forgotten-export) The symbol "DeepPartialArray" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialObject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type DeepPartial<T> = T extends Function ? T : T extends Array<infer InferredArrayMember> ? DeepPartialArray<InferredArrayMember> : T extends object ? DeepPartialObject<T> : T | undefined;

// @public (undocumented)
type DeepPick<T, U> = UnionToIntersection<PropPath<T, U>>;

// @public (undocumented)
type DeepReadonly<T extends Record<PropertyKey, any>> = T extends (...args: any[]) => any ? T : {
    readonly [Key in keyof T]: DeepReadonly<T[Key]>;
};

// @public (undocumented)
function defineStore<State, Getters, Actions, _Getters = {
    readonly [P in keyof Getters]: GetRes<Getters[P]>;
}>(store: {
    id: string;
    state: (this: void) => State;
    getters?: Getters & ThisType<_Getters & Readonly<State>>;
    actions?: Actions & ThisType<State & _Getters & Actions>;
}): State & _Getters & Actions;

// @public (undocumented)
type Diff<T, S> = {
    [K in Exclude<keyof T | keyof S, keyof T & keyof S>]: (T & S)[K];
};

// @public (undocumented)
type DiscrimatedUnionToObject<T extends Record<PropertyKey, any>, U extends keyof T> = {
    [P in T as P[U]]: [Exclude<keyof P, U>] extends [never] ? unknown : {
        [Key in Exclude<keyof P, U>]: P[Key];
    };
};

// @public (undocumented)
type DropString<S, R extends string> = R extends "" ? S : S extends `${infer F}${infer RT}` ? F extends StringToUnion<R> ? DropString<RT, R> : `${F}${DropString<RT, R>}` : S;

// @public (undocumented)
type EndsWith<T extends string, U extends string> = T extends `${string}${U}` ? true : false;

// @public (undocumented)
type Enum<T extends readonly string[], N extends boolean = false> = {
    readonly [Key in T[number] as `${Capitalize<Key>}`]: N extends false ? Key : FindIndex<T, Key>;
};

// @public (undocumented)
type Equal<T, U> = (<P>(x: P) => P extends T ? 1 : 2) extends <P>(x: P) => P extends U ? 1 : 2 ? true : false;

// @public (undocumented)
type Expect<T extends true> = T;

// @public (undocumented)
type ExpectFalse<T extends false> = T;

// @public (undocumented)
type ExpectTrue<T extends true> = T;

// @public (undocumented)
type ExtractValuesOfTuple<T extends any[]> = T[keyof T & number];

// @public (undocumented)
type FalsyValues = "" | [] | Record<PropertyKey, never> | 0 | false | undefined | null;

// @public (undocumented)
type Fibonacci<T extends number, C extends unknown[] = [], U1 extends unknown[] = [], U2 extends unknown[] = [unknown]> = T extends C["length"] ? U1["length"] : Fibonacci<T, [unknown, ...C], U2, [...U1, ...U2]>;

// @public (undocumented)
type Fill<T extends unknown[], N, Start extends number = 0, End extends number = T["length"], P extends number = 0> = Start extends End ? T : T extends [infer F, ...infer RT] ? P extends Start ? [N, ...Fill<RT, N, PlusOne<Start>, End, PlusOne<P>>] : [F, ...Fill<RT, N, Start, End, PlusOne<P>>] : [];

// @public (undocumented)
type Filter<T extends any[], U, ACC extends any[] = []> = T extends [infer F, ...infer RT] ? F extends U ? Filter<RT, U, [...ACC, F]> : Filter<RT, U, ACC> : ACC;

// @public (undocumented)
type FilterOut<T extends any[], U, ACC extends any[] = []> = T extends [
infer F,
...infer REST
] ? [F] extends [U] ? FilterOut<REST, U, ACC> : FilterOut<REST, U, [...ACC, F]> : ACC;

// @public (undocumented)
type FindIndex<T extends readonly any[], K, ACC extends unknown[] = []> = T extends readonly [infer F, ...infer RT] ? K extends F ? ACC["length"] : FindIndex<RT, K, [...ACC, unknown]> : -1;

// @public (undocumented)
type First<T extends any[]> = T extends [infer First, ...infer _] ? First : never;

// @public (undocumented)
type Flatten<T> = T extends [] ? [] : T extends [infer H, ...infer T] ? [...Flatten<H>, ...Flatten<T>] : [T];

// @public (undocumented)
type GenNode<K extends string | number, IsRoot extends boolean> = IsRoot extends true ? `${K}` : `.${K}` | (K extends number ? `[${K}]` | `.[${K}]` : never);

// @public (undocumented)
type Get<T extends Record<PropertyKey, any>, K extends string> = K extends keyof T ? T[K] : K extends `${infer P}.${infer U}` ? Get<T[P], U> : never;

// @public (undocumented)
type GetLastUnion<U> = UnionToIntersectionFn<U> extends () => infer I ? I : never;

// @public (undocumented)
type GetOptional<T extends Record<PropertyKey, any>> = {
    [Key in keyof T as T[Key] extends Required<T>[Key] ? never : Key]: T[Key];
};

// @public (undocumented)
function getProp<T, P extends PathKeys<T>>(obj: T, path: P): PropType<T, P>;

// @public (undocumented)
type GetRequired<T extends Record<PropertyKey, any>> = {
    [Key in keyof T as T[Key] extends Required<T>[Key] ? Key : never]: T[Key];
};

// @public (undocumented)
type GetRes<T> = T extends (...args: any[]) => infer R ? R : never;

// @public (undocumented)
type GreaterThan<T extends number, U extends number, ACC extends unknown[] = []> = T extends ACC['length'] ? false : U extends ACC['length'] ? true : GreaterThan<T, U, [...ACC, unknown]>;

// @public (undocumented)
type Head<T extends any[]> = T extends [infer HEAD, ...infer _] ? HEAD : never;

// @public (undocumented)
type Identity<T> = T;

// @public (undocumented)
type If<C extends boolean, T, F> = C extends true ? T : F;

// @public (undocumented)
type Includes<T extends readonly any[], U> = T extends [
infer F,
...infer RT
] ? Equal<F, U> extends true ? true : Includes<RT, U> : false;

// @public (undocumented)
type IndexOf<T extends any[], U, ACC extends unknown[] = []> = T extends [infer F, ...infer RT] ? Equal<F, U> extends true ? ACC["length"] : IndexOf<RT, U, [...ACC, unknown]> : -1;

// Warning: (ae-forgotten-export) The symbol "TreeNode" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type InorderTraversal<T extends TreeNode | null> = [T] extends [TreeNode] ? [...InorderTraversal<T["left"]>, T["val"], ...InorderTraversal<T["right"]>] : [];

// @public (undocumented)
type Intersection<T> = T extends [infer F, ...infer RT] ? ToUnion<F> & Intersection<RT> : unknown;

// @public (undocumented)
type IsAny<T> = Equal<any, T>;

// @public (undocumented)
type IsFalse<T extends false> = T;

// @public (undocumented)
type IsInteger<T> = `${T & number}` extends `${number}.${number}` ? never : number extends T ? never : T;

// @public (undocumented)
type isNegative<T extends number> = NumberToString<T> extends `-${number}` ? true : false;

// @public (undocumented)
type IsNever<T> = [T] extends [never] ? true : false;

// @public (undocumented)
type IsPalindrome<T extends string | number> = Equal<`${T}`, Join<Reverse<Split<`${T}`, "">>, "">>;

// @public (undocumented)
type IsRequiredKey<T, K extends keyof T> = Equal<K, RequiredKeys<T>> extends true ? true : false;

// @public (undocumented)
type IsTrue<T extends true> = T;

// @public (undocumented)
type IsTuple<T> = [T] extends [never] ? false : T extends readonly any[] ? any[] extends T ? false : true : false;

// @public (undocumented)
type Join<T extends any[], U extends string | number, ACC extends string = ""> = T extends [infer A extends string, ...infer RT extends string[]] ? RT["length"] extends 0 ? `${ACC}${A}` : Join<RT, U, `${ACC}${A}${U}`> : ACC;

// @public (undocumented)
function join<S extends string>(delimiter: S): <Args extends string[]>(...parts: Args) => ConcatString<Args, S>;

// @public (undocumented)
type KebabCase<S extends string> = S extends `${infer First}${infer REST}` ? REST extends Uncapitalize<REST> ? `${Lowercase<First>}${KebabCase<REST>}` : `${Lowercase<First>}-${KebabCase<REST>}` : S;

// @public (undocumented)
type KeyStartsWith<Obj extends Record<PropertyKey, any>, Matcher extends string | number | symbol, _ExtractedKey extends keyof Obj = Extract<keyof Obj, Matcher>> = {
    [K in _ExtractedKey]: Obj[K];
}[_ExtractedKey];

// @public (undocumented)
type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never;

// @public (undocumented)
type LastIndexOf<T extends any[], U> = T extends [...infer RT, infer L] ? Equal<L, U> extends true ? RT["length"] : LastIndexOf<RT, U> : -1;

// @public (undocumented)
type Length<T extends readonly any[]> = T["length"];

// @public (undocumented)
type LengthOfString<S extends string, ACC extends unknown[] = []> = S extends `${string}${string}${string}${string}${string}${string}${string}${string}${string}${string}${infer REST}` ? LengthOfString<REST, [
...ACC,
unknown,
unknown,
unknown,
unknown,
unknown,
unknown,
unknown,
unknown,
unknown,
unknown
]> : S extends `${string}${infer REST}` ? LengthOfString<REST, [...ACC, unknown]> : ACC["length"];

// Warning: (ae-forgotten-export) The symbol "LookUpLike" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "LookUpKey" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type LookUp<U extends Record<PropertyKey, any>, T extends Record<PropertyKey, any> | string, K extends string = "type"> = T extends Record<PropertyKey, any> ? LookUpLike<U, T> : T extends string ? LookUpKey<U, T, K> : never;

// @public (undocumented)
type LowerLetterUnion = StringToUnion<"abcdefghijklmnopqrstuvwxyz">;

// @public (undocumented)
type MapTypes<T extends Record<PropertyKey, any>, R extends Record<"mapFrom" | "mapTo", any>> = {
    [K in keyof T]: T[K] extends R["mapFrom"] ? R extends {
        mapFrom: T[K];
    } ? R["mapTo"] : never : T[K];
};

// @public (undocumented)
type Maybe<T extends Record<PropertyKey, unknown>> = T | null | undefined;

// @public (undocumented)
type Merge<F extends Record<PropertyKey, any>, S extends Record<PropertyKey, any>> = {
    [Key in keyof (F & S)]: Key extends keyof S ? S[Key] : Key extends keyof F ? F[Key] : never;
};

// @public (undocumented)
type MergeObject<T> = {
    [P in keyof T]: T[P];
};

// @public
type MinusN<T extends number, N extends number, NACC extends unknown[] = []> = [...NACC]['length'] extends N ? T : MinusN<MinusOne<T>, N, [...NACC, unknown]>;

// @public (undocumented)
type MinusOne<T extends number, ARR extends unknown[] = []> = any extends never ? never : [...ARR, 1]['length'] extends T ? ARR['length'] : MinusOne<T, [...ARR, 1]>;

// @public (undocumented)
type Mutable<T extends object> = {
    -readonly [K in keyof T]: T[K];
};

// @public (undocumented)
type MutableKeys<T> = keyof {
    [Key in keyof T as Equal<Pick<T, Key>, Readonly<Pick<T, Key>>> extends true ? never : Key]: T[Key];
};

// @public (undocumented)
type NonEmptyArray<T> = [T, ...Array<T>];

// @public (undocumented)
type NotAny<T> = true extends IsAny<T> ? false : true;

// @public (undocumented)
type NotEqual<X, Y> = true extends Equal<X, Y> ? false : true;

// @public (undocumented)
type Nullable<T extends Record<PropertyKey, unknown>> = {
    [K in keyof T]: T[K] | null;
};

// @public (undocumented)
type NumberRange<L extends number | C['length'], H extends number, ACC = never, C extends unknown[] = []> = C['length'] extends H ? ACC | H : C['length'] extends L ? NumberRange<[...C, unknown]['length'], H, L | ACC, [...C, unknown]> : NumberRange<L, H, ACC, [...C, unknown]>;

// @public
type NumberToArray<T extends number, R extends 1[] = []> = R["length"] extends T ? R : NumberToArray<T, [...R, 1]>;

// @public (undocumented)
type NumberToString<T extends number> = `${T}`;

// @public (undocumented)
type ObjectEntries<T extends object> = {
    [Key in keyof T]-?: Key extends keyof T ? [Key, T[Key] extends undefined ? undefined : Required<T>[Key]] : never;
}[keyof T];

// @public (undocumented)
type ObjectFromEntries<T extends any[]> = {
    [Key in T as Key extends any[] ? Key[0] extends string ? Key[0] : never : never]: Key[1];
};

// @public (undocumented)
type ObjectKeyPaths<T extends object, IsRoot extends boolean = true, K extends keyof T = keyof T> = K extends string | number ? GenNode<K, IsRoot> | (T[K] extends object ? `${GenNode<K, IsRoot>}${ObjectKeyPaths<T[K], false>}` : never) : never;

// @public (undocumented)
type ObjectToUnion<T> = {
    [Key in keyof T]: Record<Key, T[Key]>;
}[keyof T];

// @public (undocumented)
type OmitByType<T extends object, U> = {
    [Key in keyof T as T[Key] extends U ? never : Key]: T[Key];
};

// @public (undocumented)
type OnPropChnagedMethods<T> = {
    [Key in keyof T & string as `${Key}Changed`]: (cb: (newValue: T[Key]) => void) => void;
};

// @public (undocumented)
type OptionalKeys<T extends Record<PropertyKey, any>> = keyof {
    [Key in keyof T as T[Key] extends Required<T>[Key] ? never : Key]: any;
};

// Warning: (ae-forgotten-export) The symbol "Grouping" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MapToKeyValPair" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "SplitQuery" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type ParseQueryString<T extends string> = T extends "" ? Record<PropertyKey, unknown> : Grouping<MapToKeyValPair<SplitQuery<T>>>;

// @public (undocumented)
type PartialByKeys<T, K extends keyof T = keyof T> = MergeObject<Omit<T, K> & {
    [P in keyof T as P extends K ? P : never]?: T[P];
}>;

// @public (undocumented)
type PathKeys<T> = object extends T ? string : T extends readonly any[] ? Extract<keyof T, `${number}`> | SubKeys<T, Extract<keyof T, `${number}`>> : T extends object ? Extract<keyof T, string> | SubKeys<T, Extract<keyof T, string>> : never;

// @public (undocumented)
type PathParams<S extends string> = S extends `/${string}/:${infer Param}/${infer REST}` ? Param | PathParams<`/${REST}`> : S extends `${string}/:${infer Param}` ? Param : never;

// @public (undocumented)
type PathParamsObj<S extends string> = S extends `/${string}/:${infer Param}/${infer REST}` ? MergeObject<{
    [Key in Param]: string;
} & PathParamsObj<`/${REST}`>> : S extends `${string}/:${infer Param}` ? {
    [Key in Param]: string;
} : never;

// @public (undocumented)
type Permutation<T, U = T> = [T] extends [never] ? [] : U extends any ? [U, ...Permutation<Exclude<T, U>>] : [];

// @public (undocumented)
type Permutations<S extends string> = Combinations<StringToUnion<S>>;

// @public (undocumented)
type PickByType<T extends object, U> = {
    [Key in keyof T as T[Key] extends U ? Key : never]: T[Key];
};

// @public (undocumented)
type Placeholder<T extends string> = T extends `${string}{${infer P}}${infer REST}` ? P | Placeholder<REST> : never;

// @public (undocumented)
type PlusOne<T extends number, C extends unknown[] = []> = C['length'] extends T ? [...C, unknown]['length'] : PlusOne<T, [...C, unknown]>;

// @public (undocumented)
type Pop<T extends any[]> = T extends [...infer RT, infer _] ? RT : [];

// @public (undocumented)
export type Primitive = string | number | boolean | null;

// @public (undocumented)
function PromiseAll<T extends any[]>(values: readonly [...T]): Promise<{
    [Key in keyof T]: T[Key] extends Promise<infer V> ? V : T[Key];
}>;

// @public (undocumented)
type Properties<T extends {
    new (...args: any[]): any;
}> = keyof InstanceType<T>;

// @public (undocumented)
type PropPath<T, U> = U extends keyof T ? {
    [Key in U]: T[Key];
} : U extends `${infer P}.${infer RT}` ? P extends keyof T ? {
    [Key in P]: PropPath<T[Key], RT>;
} : never : never;

// @public (undocumented)
type PropType<T, Path extends string> = Path extends keyof T ? T[Path] : Path extends `${infer K}.${infer RT}` ? K extends keyof T ? PropType<T[K], RT> : unknown : unknown;

// @public (undocumented)
type Push<T extends any[], U> = [...T, U];

// @public (undocumented)
type ReadonlyKeys<T> = keyof {
    [Key in keyof T as Equal<Pick<T, Key>, Readonly<Pick<T, Key>>> extends true ? Key : never]: T[Key];
};

// @public (undocumented)
type Replace<S extends string, From extends string, To extends string> = From extends "" ? S : S extends `${infer A}${From}${infer B}` ? `${A}${To}${B}` : S;

// @public (undocumented)
type ReplaceAll<S extends string, From extends string, To extends string> = From extends "" ? S : S extends `${infer A}${From}${infer B}` ? `${A}${To}${ReplaceAll<B, From, To>}` : S;

// @public (undocumented)
type RequiredByKeys<T, K extends keyof T = keyof T> = MergeObject<Omit<T, K> & {
    [Key in keyof T as Key extends K ? Key : never]-?: T[Key];
}>;

// @public (undocumented)
type RequiredKeys<T extends Record<PropertyKey, any>> = keyof {
    [Key in keyof T as T[Key] extends Required<T>[Key] ? Key : never]: any;
};

// @public (undocumented)
type Reverse<T> = T extends [...infer H, infer T] ? [T, ...Reverse<H>] : [];

// @public (undocumented)
type Shift<T extends any[]> = T extends [infer _, ...infer REST] ? REST : [];

// Warning: (ae-forgotten-export) The symbol "SliceRightIgnoreSign" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "SliceLeftIgnoreSign" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type Slice<Arr extends readonly any[], Start extends number = 0, End extends number = Arr['length']> = `${Start}` extends `-${string}` ? SliceRightIgnoreSign<SliceLeftIgnoreSign<Arr, Start>, End> : SliceLeftIgnoreSign<SliceRightIgnoreSign<Arr, End>, Start>;

// @public (undocumented)
type SnakeCase<T, ACC extends string = ''> = T extends `${infer F}${infer REST}` ? Uppercase<F> extends F ? SnakeCase<REST, `${ACC}_${Lowercase<F>}`> : SnakeCase<REST, `${ACC}${F}`> : ACC;

// @public (undocumented)
type Space = " " | "\n" | "\t";

// @public (undocumented)
type Split<S extends string, SEP extends string> = Equal<S, string> extends true ? S[] : S extends `${infer P}${SEP}${infer RT}` ? [P, ...Split<RT, SEP>] : S extends "" ? SEP extends "" ? [] : [S] : [S];

// @public (undocumented)
type StartsWith<T extends string, U extends string> = T extends `${U}${string}` ? true : false;

// @public (undocumented)
type StringToUnion<S extends string> = S extends `${infer A}${infer B}` ? A | StringToUnion<B> : "";

// @public (undocumented)
type SubKeys<T, K extends string> = K extends keyof T ? `${K}.${PathKeys<T[K]>}` : never;

// @public (undocumented)
type Subsequence<T extends any[]> = T extends [infer F, ...infer RT] ? Subsequence<RT> | [F, ...Subsequence<RT>] : [];

// @beta
export function sum3(a: number, b: number, c: number): number;

// @public (undocumented)
type ToNumber<S extends string, ACC extends unknown[] = []> = S extends `${number}` ? S extends `${ACC["length"]}` ? ACC["length"] : ToNumber<S, [...ACC, unknown]> : never;

// Warning: (ae-forgotten-export) The symbol "ArrayToPrimitive" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ObjectToPrimitive" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ValueToPrimitive" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type ToPrimitive<T extends Record<PropertyKey, any>> = {
    [Key in keyof T]: T[Key] extends any[] ? ArrayToPrimitive<T[Key]> : T[Key] extends object ? ObjectToPrimitive<T[Key]> : ValueToPrimitive<T[Key]>;
};

// @public
type ToUnion<T> = T extends any[] ? T[number] : T;

// @public (undocumented)
type Trim<S extends string> = S extends `${Space}${infer Word}` ? Trim<Word> : S extends `${infer Word}${Space}` ? Trim<Word> : S;

// @public (undocumented)
type TrimLeft<S extends string> = S extends `${Space}${infer RT}` ? TrimLeft<RT> : S;

// @public (undocumented)
type TrimRight<S extends string> = S extends `${infer Left}${Space}` ? TrimRight<Left> : S;

// @public (undocumented)
type Trunc<N extends number | string> = `${N}` extends `${infer NUM}.${infer _}` ? `${NUM}` : `${N}`;

// @public (undocumented)
type TupleToNestedObject<T extends any[], U> = T extends [
infer A extends string,
...infer REST
] ? {
    [Key in A]: TupleToNestedObject<REST, U>;
} : U;

// @public (undocumented)
type TupleToObject<T extends ReadonlyArray<string | number>> = {
    [Key in T[number]]: Key;
};

// @public (undocumented)
type TupleToUnion<T extends any[]> = T extends [infer F, ...infer RT] ? F | TupleToUnion<RT> : never;

// Warning: (ae-forgotten-export) The symbol "RecursiveAdd" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type TwoSum<T extends number[], U extends number> = T extends [
infer F extends number,
...infer RT extends number[]
] ? RecursiveAdd<F, RT, U> extends false ? TwoSum<RT, U> : true : false;

declare namespace types {
    export {
        All,
        AnyOf,
        ConstructTuple,
        Chunk,
        Enum,
        FindIndex,
        Fill,
        Filter,
        FilterOut,
        Flatten,
        First,
        Length,
        Last,
        LastIndexOf,
        Head,
        Shift,
        Join,
        NonEmptyArray,
        Includes,
        IndexOf,
        Push,
        Pop,
        Permutation,
        Reverse,
        Unshift,
        Subsequence,
        TupleToObject,
        TupleToNestedObject,
        Unique,
        Without,
        Zip,
        Properties,
        ClassPublicKeys,
        defineStore,
        GetRes,
        join,
        AppendArgument,
        If,
        InorderTraversal,
        Fibonacci,
        Placeholder,
        OnPropChnagedMethods,
        IsPalindrome,
        TwoSum,
        UnionReplace,
        Absolute,
        MinusOne,
        MinusN,
        PlusOne,
        GreaterThan,
        NumberRange,
        Trunc,
        getProp,
        Assign,
        AppendToObject,
        PropPath,
        DeepPick,
        CapitalizeNestObjectKeys,
        DeepReadonly,
        DeepPartial,
        DeepMutable,
        Diff,
        Get,
        GetRequired,
        GetOptional,
        KeyStartsWith,
        LookUp,
        PartialByKeys,
        MergeObject,
        Merge,
        PickByType,
        OmitByType,
        RequiredByKeys,
        MapTypes,
        Mutable,
        MutableKeys,
        ObjectEntries,
        ObjectFromEntries,
        GenNode,
        ObjectKeyPaths,
        OptionalKeys,
        RequiredKeys,
        IsRequiredKey,
        ReadonlyKeys,
        PathKeys,
        SubKeys,
        PropType,
        PromiseAll,
        ParseQueryString,
        PathParams,
        PathParamsObj,
        Slice,
        CamelizeWord,
        ConcatString,
        DropString,
        CapitalizeWords,
        LengthOfString,
        StartsWith,
        EndsWith,
        Combinations,
        Permutations,
        Replace,
        Trim,
        TrimLeft,
        ReplaceAll,
        Split,
        SnakeCase,
        TrimRight,
        UnionToIntersectionFn,
        GetLastUnion,
        UnionToTuple,
        TupleToUnion,
        Expect,
        FalsyValues,
        Space,
        Camelize,
        DiscrimatedUnionToObject,
        KebabCase,
        CamelCase,
        StringToUnion,
        LowerLetterUnion,
        UpperLetterUnion,
        Equal,
        BEM,
        ToPrimitive,
        NumberToArray,
        BinaryToDecimal,
        ToUnion,
        Intersection,
        UnionToIntersection,
        ExtractValuesOfTuple,
        Identity,
        IsAny,
        NotAny,
        IsTuple,
        IsInteger,
        IsNever,
        ExpectTrue,
        ExpectFalse,
        IsTrue,
        IsFalse,
        isNegative,
        NumberToString,
        ObjectToUnion,
        ToNumber,
        Nullable,
        NotEqual,
        Maybe,
        XOR
    }
}
export { types }

// @public
type UnionReplace<T, U extends [any, any][]> = U extends [
infer F,
...infer RT extends [any, any][]
] ? F extends [infer ToBeReplaced, infer Replacer] ? UnionReplace<Exclude<T, ToBeReplaced> | Replacer, RT> : UnionReplace<T, RT> : T;

// @public (undocumented)
type UnionToIntersection<U> = (U extends any ? (x: U) => any : never) extends (x: infer R) => any ? R : never;

// @public (undocumented)
type UnionToIntersectionFn<U> = (U extends any ? (arg: () => U) => void : never) extends (arg: infer I) => void ? I : never;

// @public (undocumented)
type UnionToTuple<U, Last = GetLastUnion<U>> = [U] extends [never] ? [] : [...UnionToTuple<Exclude<U, Last>>, Last];

// @public (undocumented)
type Unique<T extends any[], ACC extends any[] = []> = T extends [
infer F,
...infer RT
] ? IndexOf<ACC, F> extends -1 ? Unique<RT, [...ACC, F]> : Unique<RT, ACC> : ACC;

// @public (undocumented)
type Unshift<T extends any[], U> = [U, ...T];

// @public (undocumented)
type UpperLetterUnion = Uppercase<LowerLetterUnion>;

// @public (undocumented)
type Without<T extends any[], U extends any[] | any> = T extends [
infer F,
...infer RT
] ? U extends any[] ? F extends U[number] ? Without<RT, U> : [F, ...Without<RT, U>] : F extends U ? Without<RT, U> : [F, ...Without<RT, U>] : [];

// @public (undocumented)
type XOR<N extends boolean, M extends boolean> = [N, M] extends [
true,
true
] ? false : [N, M] extends [false, false] ? false : true;

// @public (undocumented)
type Zip<T, U> = T extends [infer F1, ...infer R1] ? U extends [infer F2, ...infer R2] ? [[F1, F2], ...Zip<R1, R2>] : [] : [];

// (No @packageDocumentation comment for this package)

```
