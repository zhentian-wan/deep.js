## API Report File for "deep.js"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
type Absolute<T extends number | string | bigint> = `${T}` extends `-${infer S}` ? S : `${T}`;

// @public (undocumented)
type Alike<X, Y> = Equal<MergeInsertions<X>, MergeInsertions<Y>>;

// @public (undocumented)
type All<T extends any[], U extends any = T[0]> = T extends [infer H, ...infer RT] ? Equal<H, U> extends true ? All<RT, U> : false : true;

// @public
type And<B1 extends boolean, B2 extends boolean> = B1 extends true ? (B2 extends true ? true : false) : false;

// @public (undocumented)
type AnyOf<T extends readonly any[]> = T extends [infer F, ...infer RT] ? F extends FalsyValues ? AnyOf<RT> : true : false;

// @public (undocumented)
type AppendArgument<Fn extends (...args: any[]) => void, A> = Fn extends (...args: infer Args) => infer RT ? (...x: [...Args, A]) => RT : never;

// @public (undocumented)
type AppendToObject<T extends Record<PropertyKey, any>, U extends string | number | symbol, V> = MergeObject<T & {
    [Key in U]: V;
}>;

// @public
type Assign<T extends Record<string, unknown>, U> = U extends object[] ? U extends [infer F, ...infer RT] ? Assign<MergeObject<({
    [Key in keyof T as Key extends keyof F ? never : Key]: T[Key];
} & {
    [Key in keyof F]: F[Key];
})>, RT> : T : T;

// @public
export function avg(a: number, b: number, c: number): number;

// @public (undocumented)
type BEM<B extends string, E extends string[], M extends string[]> = M["length"] extends 0 ? `${B}__${E[number]}` : E["length"] extends 0 ? `${B}--${M[number]}` : `${B}__${E[number]}--${M[number]}`;

// Warning: (ae-forgotten-export) The symbol "GetTwice" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type BinaryToDecimal<S extends string, Result extends unknown[] = []> = S extends `${infer First extends number}${infer RT}` ? BinaryToDecimal<RT, [...GetTwice<Result>, ...NumberToArray<First>]> : Result["length"];

// @public (undocumented)
type Brand<K, T> = T & {
    [brand]: K;
};

// Warning: (ae-forgotten-export) The symbol "ToCamelCase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type CamelCase<S extends string> = ToCamelCase<Lowercase<S>>;

// @public (undocumented)
type Camelize<T> = T extends any[] ? T extends [infer F, ...infer RT] ? [Camelize<F>, ...Camelize<RT>] : [] : {
    [Key in keyof T as Key extends string ? `${CamelizeWord<Key>}` : never]: T[Key] extends object ? Camelize<T[Key]> : T[Key];
};

// @public (undocumented)
type CamelizeWord<S> = S extends `${infer F}_${infer RT}` ? `${F}${CamelizeWord<Capitalize<RT>>}` : S;

// @public
type CapitalizeNestObjectKeys<T> = T extends any[] ? T extends [infer F, ...infer R] ? [CapitalizeNestObjectKeys<F>, ...CapitalizeNestObjectKeys<R>] : [] : T extends object ? {
    [K in keyof T as K extends string ? Capitalize<K> : never]: CapitalizeNestObjectKeys<T[K]>;
} : T;

// @public (undocumented)
type CapitalizeWords<S extends string, Prev extends string = "", ACC extends string = ""> = S extends `${infer First}${infer REST}` ? Uppercase<Prev> extends UpperLetterUnion ? CapitalizeWords<REST, First, `${ACC}${First}`> : CapitalizeWords<REST, First, `${ACC}${Uppercase<First>}`> : ACC;

// @public (undocumented)
type Chunk<T extends any[], U extends number, ACC extends any[] = []> = ACC["length"] extends U ? [ACC, ...Chunk<T, U>] : T extends [infer F, ...infer RT] ? Chunk<RT, U, [...ACC, F]> : ACC["length"] extends 0 ? [] : [ACC];

// @public (undocumented)
type ClassPublicKeys<C> = keyof C;

// @public (undocumented)
type Combinations<T extends string, U = T> = U extends T ? U | `${U}${Combinations<Exclude<T, U>>}` : never;

// Warning: (ae-forgotten-export) The symbol "Compare" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type Comparator<A extends number, B extends number> = A extends B ? Comparison.Equal : [Negative<A>, Negative<B>] extends [infer AA, infer BB] ? [AA, BB] extends [false, false] ? Compare<A, B> : [AA, BB] extends [false, number] ? Comparison.Greater : [AA, BB] extends [number, false] ? Comparison.Lower : Compare<BB & number, AA & number> : never;

// @public
enum Comparison {
    // (undocumented)
    Equal = 1,
    // (undocumented)
    Greater = 0,
    // (undocumented)
    Lower = 2
}

// @public (undocumented)
type ConcatString<T extends unknown[], U extends string, ACC extends string = ""> = T extends [infer F extends string, ...infer RT] ? ACC extends "" ? ConcatString<RT, U, `${F}`> : ConcatString<RT, U, `${ACC}${U}${F}`> : ACC;

// @public (undocumented)
type ConstructTuple<L extends number, ACC extends unknown[] = []> = L extends 0 ? [] : ACC["length"] extends L ? ACC : ConstructTuple<L, [...ACC, unknown]>;

// @public (undocumented)
type Debug<T> = {
    [K in keyof T]: T[K];
};

// @public
export function deepFreeze(obj: {
    [K: string]: Primitive | object;
}): Readonly<{
    [K: string]: object | Primitive;
}>;

// @public (undocumented)
type DeepMutable<T extends Record<PropertyKey, any>> = T extends (...args: any[]) => any ? T : {
    -readonly [K in keyof T]: DeepMutable<T[K]>;
};

// Warning: (ae-forgotten-export) The symbol "DeepPartialArray" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DeepPartialObject" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type DeepPartial<T> = T extends (...args: any[]) => void ? T : T extends Array<infer InferredArrayMember> ? DeepPartialArray<InferredArrayMember> : T extends object ? DeepPartialObject<T> : T | undefined;

// @public (undocumented)
type DeepPick<T, U> = UnionToIntersection<PropPath<T, U>>;

// @public (undocumented)
type DeepReadonly<T extends Record<PropertyKey, any>> = T extends (...args: any[]) => any ? T : {
    readonly [Key in keyof T]: DeepReadonly<T[Key]>;
};

// @public (undocumented)
function defineStore<State, Getters, Actions, _Getters = {
    readonly [P in keyof Getters]: GetRes<Getters[P]>;
}>(store: {
    id: string;
    state: (this: void) => State;
    getters?: Getters & ThisType<_Getters & Readonly<State>>;
    actions?: Actions & ThisType<State & _Getters & Actions>;
}): State & _Getters & Actions;

// @public (undocumented)
type Diff<T, S> = {
    [K in Exclude<keyof T | keyof S, keyof T & keyof S>]: (T & S)[K];
};

// @public (undocumented)
type DiscrimatedUnionToObject<T extends Record<PropertyKey, any>, U extends keyof T> = {
    [P in T as P[U]]: [Exclude<keyof P, U>] extends [never] ? unknown : {
        [Key in Exclude<keyof P, U>]: P[Key];
    };
};

// @public (undocumented)
type DropString<S, R extends string> = R extends "" ? S : S extends `${infer F}${infer RT}` ? F extends StringToUnion<R> ? DropString<RT, R> : `${F}${DropString<RT, R>}` : S;

// @public (undocumented)
function DynamicParamsCurrying<T extends any[], R>(fn: (...args: T) => R): T extends [] ? R : <P extends any[]>(...args: P) => T extends [...P, ...infer K3] ? ReturnType<typeof DynamicParamsCurrying<K3, R>> : R;

// @public (undocumented)
type EndsWith<T extends string, U extends string> = T extends `${string}${U}` ? true : false;

// @public (undocumented)
type Enum<T extends readonly string[], N extends boolean = false> = {
    readonly [Key in T[number] as `${Capitalize<Key>}`]: N extends false ? Key : FindIndex<T, Key>;
};

// @public (undocumented)
type EnumLike = {
    [k: string]: string | number;
    [nu: number]: string;
};

// @public (undocumented)
type Equal<T, U> = (<P>(x: P) => P extends T ? 1 : 2) extends <P>(x: P) => P extends U ? 1 : 2 ? true : false;

// @public (undocumented)
type Exclusive<T extends Record<PropertyKey, unknown>, U extends Record<PropertyKey, unknown>> = (T & {
    [k in Exclude<keyof U, keyof T>]?: never;
}) | (U & {
    [k in Exclude<keyof T, keyof U>]?: never;
});

// @public (undocumented)
type Expect<T extends true> = T;

// @public (undocumented)
type ExpectExtends<VALUE, EXPECTED> = EXPECTED extends VALUE ? true : false;

// @public (undocumented)
type ExpectFalse<T extends false> = T;

// @public (undocumented)
type ExpectTrue<T extends true> = T;

// @public (undocumented)
type ExpectValidArgs<FUNC extends (...args: any[]) => any, ARGS extends any[]> = ARGS extends Parameters<FUNC> ? true : false;

// @public (undocumented)
type ExtractValuesOfTuple<T extends any[]> = T[keyof T & number];

// @public (undocumented)
type FalsyValues = "" | [] | Record<PropertyKey, never> | 0 | false | undefined | null;

// @public (undocumented)
type Fibonacci<T extends number, C extends unknown[] = [], U1 extends unknown[] = [], U2 extends unknown[] = [unknown]> = T extends C["length"] ? U1["length"] : Fibonacci<T, [unknown, ...C], U2, [...U1, ...U2]>;

// @public (undocumented)
type Fill<T extends unknown[], N, Start extends number = 0, End extends number = T["length"], P extends number = 0> = Start extends End ? T : T extends [infer F, ...infer RT] ? P extends Start ? [N, ...Fill<RT, N, PlusOne<Start>, End, PlusOne<P>>] : [F, ...Fill<RT, N, Start, End, PlusOne<P>>] : [];

// @public (undocumented)
type Filter<T extends any[], U, ACC extends any[] = []> = T extends [infer F, ...infer RT] ? F extends U ? Filter<RT, U, [...ACC, F]> : Filter<RT, U, ACC> : ACC;

// @public (undocumented)
type FilterOut<T extends any[], U, ACC extends any[] = []> = T extends [
infer F,
...infer REST
] ? [F] extends [U] ? FilterOut<REST, U, ACC> : FilterOut<REST, U, [...ACC, F]> : ACC;

// @public (undocumented)
type FindIndex<T extends readonly any[], K, ACC extends unknown[] = []> = T extends readonly [infer F, ...infer RT] ? K extends F ? ACC["length"] : FindIndex<RT, K, [...ACC, unknown]> : -1;

// @public (undocumented)
type First<T extends any[]> = T extends [infer First, ...infer _] ? First : never;

// @public (undocumented)
type Flatten<T> = T extends [] ? [] : T extends [infer H, ...infer T] ? [...Flatten<H>, ...Flatten<T>] : [T];

// @public (undocumented)
type GenNode<K extends string | number, IsRoot extends boolean> = IsRoot extends true ? `${K}` : `.${K}` | (K extends number ? `[${K}]` | `.[${K}]` : never);

// @public (undocumented)
type Get<T extends Record<PropertyKey, any>, K extends string> = K extends keyof T ? T[K] : K extends `${infer P}.${infer U}` ? Get<T[P], U> : never;

// @public (undocumented)
type GetLastUnion<U> = UnionToIntersectionFn<U> extends () => infer I ? I : never;

// @public (undocumented)
type GetOptional<T extends Record<PropertyKey, any>> = {
    [Key in keyof T as T[Key] extends Required<T>[Key] ? never : Key]: T[Key];
};

// @public (undocumented)
function getProp<T, P extends PathKeys<T>>(obj: T, path: P): PropType<T, P>;

// @public (undocumented)
type GetRequired<T extends Record<PropertyKey, any>> = {
    [Key in keyof T as T[Key] extends Required<T>[Key] ? Key : never]: T[Key];
};

// @public (undocumented)
type GetRes<T> = T extends (...args: any[]) => infer R ? R : never;

// @public (undocumented)
type GreaterThan<T extends number, U extends number, ACC extends unknown[] = []> = T extends ACC['length'] ? false : U extends ACC['length'] ? true : GreaterThan<T, U, [...ACC, unknown]>;

// @public (undocumented)
type Head<T extends any[]> = T extends [infer HEAD, ...infer _] ? HEAD : never;

// @public (undocumented)
type If<C extends boolean, T, F> = C extends true ? T : F;

// @public (undocumented)
type Includes<T extends readonly any[], U> = T extends [
infer F,
...infer RT
] ? Equal<F, U> extends true ? true : Includes<RT, U> : false;

// @public (undocumented)
type IndexOf<T extends any[], U, ACC extends unknown[] = []> = T extends [infer F, ...infer RT] ? Equal<F, U> extends true ? ACC["length"] : IndexOf<RT, U, [...ACC, unknown]> : -1;

// Warning: (ae-forgotten-export) The symbol "TreeNode" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type InorderTraversal<T extends TreeNode | null> = [T] extends [TreeNode] ? [...InorderTraversal<T["left"]>, T["val"], ...InorderTraversal<T["right"]>] : [];

// @public (undocumented)
type Intersection<T> = T extends [infer F, ...infer RT] ? ToUnion<F> & Intersection<RT> : unknown;

// @public (undocumented)
type IsAny<T> = Equal<any, T>;

// @public (undocumented)
type IsFalse<T extends false> = T;

// @public (undocumented)
type IsInteger<T> = `${T & number}` extends `${number}.${number}` ? never : number extends T ? never : T;

// @public (undocumented)
type isNegative<T extends number> = NumberToString<T> extends `-${number}` ? true : false;

// @public (undocumented)
type IsNever<T> = [T] extends [never] ? true : false;

// @public (undocumented)
type IsNil<T> = T extends object ? false : true;

// @public (undocumented)
type IsPalindrome<T extends string | number> = Equal<`${T}`, Join<Reverse<Split<`${T}`, "">>, "">>;

// @public (undocumented)
type IsRequiredKey<T extends Record<PropertyKey, any>, K extends keyof T> = Equal<K, RequiredKeys<T>> extends true ? true : false;

// @public (undocumented)
type IsTrue<T extends true> = T;

// @public (undocumented)
type IsTuple<T> = [T] extends [never] ? false : T extends readonly any[] ? any[] extends T ? false : true : false;

// @public (undocumented)
type Join<T extends any[], U extends string | number, ACC extends string = ""> = T extends [infer A extends string, ...infer RT extends string[]] ? RT["length"] extends 0 ? `${ACC}${A}` : Join<RT, U, `${ACC}${A}${U}`> : ACC;

// @public (undocumented)
function join<S extends string>(delimiter: S): <Args extends string[]>(...parts: Args) => ConcatString<Args, S>;

// @public (undocumented)
type KebabCase<S extends string> = S extends `${infer First}${infer REST}` ? REST extends Uncapitalize<REST> ? `${Lowercase<First>}${KebabCase<REST>}` : `${Lowercase<First>}-${KebabCase<REST>}` : S;

// @public (undocumented)
type KeyStartsWith<Obj extends Record<PropertyKey, any>, Matcher extends string | number | symbol, _ExtractedKey extends keyof Obj = Extract<keyof Obj, Matcher>> = {
    [K in _ExtractedKey]: Obj[K];
}[_ExtractedKey];

// @public (undocumented)
type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never;

// @public (undocumented)
type LastIndexOf<T extends any[], U> = T extends [...infer RT, infer L] ? Equal<L, U> extends true ? RT["length"] : LastIndexOf<RT, U> : -1;

// @public (undocumented)
type Length<T extends readonly any[]> = T["length"];

// @public (undocumented)
type LengthOfString<S extends string, ACC extends unknown[] = []> = S extends `${string}${string}${string}${string}${string}${string}${string}${string}${string}${string}${infer REST}` ? LengthOfString<REST, [
...ACC,
unknown,
unknown,
unknown,
unknown,
unknown,
unknown,
unknown,
unknown,
unknown,
unknown
]> : S extends `${string}${infer REST}` ? LengthOfString<REST, [...ACC, unknown]> : ACC["length"];

// Warning: (ae-forgotten-export) The symbol "LookUpLike" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "LookUpKey" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type LookUp<U extends Record<PropertyKey, any>, T extends Record<PropertyKey, any> | string, K extends string = "type"> = T extends Record<PropertyKey, any> ? LookUpLike<U, T> : T extends string ? LookUpKey<U, T, K> : never;

// @public (undocumented)
type LowerLetterUnion = StringToUnion<"abcdefghijklmnopqrstuvwxyz">;

// @public (undocumented)
type MapTypes<T extends Record<PropertyKey, any>, R extends Record<"mapFrom" | "mapTo", any>> = {
    [K in keyof T]: T[K] extends R["mapFrom"] ? R extends {
        mapFrom: T[K];
    } ? R["mapTo"] : never : T[K];
};

// @public (undocumented)
type Maybe<T extends object> = T | null | undefined;

// @public (undocumented)
type Merge<F extends Record<PropertyKey, any>, S extends Record<PropertyKey, any>> = {
    [Key in keyof (F & S)]: Key extends keyof S ? S[Key] : Key extends keyof F ? F[Key] : never;
};

// @public (undocumented)
type MergeInsertions<T> = T extends object ? {
    [K in keyof T]: MergeInsertions<T[K]>;
} : T;

// @public (undocumented)
type MergeObject<T> = {
    [P in keyof T]: T[P];
};

// @public
type MinusN<T extends number, N extends number, NACC extends unknown[] = []> = [...NACC]['length'] extends N ? T : MinusN<MinusOne<T>, N, [...NACC, unknown]>;

// @public (undocumented)
type MinusOne<T extends number, ARR extends unknown[] = []> = any extends never ? never : [...ARR, 1]['length'] extends T ? ARR['length'] : MinusOne<T, [...ARR, 1]>;

// Warning: (ae-forgotten-export) The symbol "ParamType" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Split" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Pop" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "EachSum" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "GetRest" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ArrayMul" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type Multiply<A extends ParamType, B extends ParamType, SA extends number[] = Split_2<A>, SB extends number[] = Split_2<B>, Result extends string[] = [], Default extends string = '', SBL extends number = Pop_2<SB>> = Equal<`${A}`, '0'> extends true ? '0' : Equal<`${B}`, '0'> extends true ? '0' : SB extends [] ? EachSum<Result> : Multiply<never, never, SA, GetRest<SB>, [ArrayMul<SA, SBL, 0, Default>, ...Result], `0${Default}`>;

// @public (undocumented)
type Mutable<T extends object> = {
    -readonly [K in keyof T]: T[K];
};

// @public (undocumented)
type MutableKeys<T> = keyof {
    [Key in keyof T as Equal<Pick<T, Key>, Readonly<Pick<T, Key>>> extends true ? never : Key]: T[Key];
};

// @public (undocumented)
export type Narrowable = string | number | bigint | boolean;

// @public (undocumented)
type Narrowable_2 = string | number | bigint | boolean;

// @public (undocumented)
type NarrowRaw<A> = (A extends [] ? [] : never) | (A extends Narrowable_2 ? A : never) | ({
    [K in keyof A]: A[K] extends (...args: any[]) => void ? A[K] : NarrowRaw<A[K]>;
});

// @public (undocumented)
type Negative<A extends number> = `${A}` extends `-${infer N extends number}` ? N : false;

// @public (undocumented)
type NeverByKeys<T, K extends keyof T = keyof T> = MergeObject<Omit<T, K> & {
    [Key in keyof T as Key extends K ? Key : never]?: never;
}>;

// @public
type NoInfer<A extends any> = [
A
][A extends any ? 0 : never];

// @public (undocumented)
type NonEmptyArray<T> = [T, ...Array<T>];

// @public (undocumented)
type NotAny<T> = true extends IsAny<T> ? false : true;

// @public (undocumented)
type NotEqual<X, Y> = true extends Equal<X, Y> ? false : true;

// @public (undocumented)
type NotNil<T> = T extends object ? true : false;

// @public (undocumented)
type Nullable<T extends Record<PropertyKey, unknown>> = {
    [K in keyof T]: T[K] | null;
};

// @public (undocumented)
type NumberRange<L extends number | C['length'], H extends number, ACC = never, C extends unknown[] = []> = C['length'] extends H ? ACC | H : C['length'] extends L ? NumberRange<[...C, unknown]['length'], H, L | ACC, [...C, unknown]> : NumberRange<L, H, ACC, [...C, unknown]>;

// @public
type NumberToArray<T extends number, R extends 1[] = []> = R["length"] extends T ? R : NumberToArray<T, [...R, 1]>;

// @public (undocumented)
type NumberToString<T extends number> = `${T}`;

// @public (undocumented)
type ObjectEntries<T extends object> = {
    [Key in keyof T]-?: Key extends keyof T ? [Key, T[Key] extends undefined ? undefined : Required<T>[Key]] : never;
}[keyof T];

// @public (undocumented)
type ObjectFromEntries<T extends any[]> = {
    [Key in T as Key extends any[] ? Key[0] extends string ? Key[0] : never : never]: Key[1];
};

// @public (undocumented)
type ObjectKeyPaths<T extends object, IsRoot extends boolean = true, K extends keyof T = keyof T> = K extends string | number ? GenNode<K, IsRoot> | (T[K] extends object ? `${GenNode<K, IsRoot>}${ObjectKeyPaths<T[K], false>}` : never) : never;

// @public (undocumented)
type ObjectToUnion<T> = {
    [Key in keyof T]: Record<Key, T[Key]>;
}[keyof T];

// @public (undocumented)
type OmitByType<T extends object, U> = {
    [Key in keyof T as T[Key] extends U ? never : Key]: T[Key];
};

// @public (undocumented)
type OnPropChnagedMethods<T> = {
    [Key in keyof T & string as `${Key}Changed`]: (cb: (newValue: T[Key]) => void) => void;
};

// @public (undocumented)
type OptionalKeys<T extends Record<PropertyKey, any>> = keyof {
    [Key in keyof T as T[Key] extends Required<T>[Key] ? never : Key]: any;
};

// Warning: (ae-forgotten-export) The symbol "Grouping" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MapToKeyValPair" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "SplitQuery" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type ParseQueryString<T extends string> = T extends "" ? Record<PropertyKey, unknown> : Grouping<MapToKeyValPair<SplitQuery<T>>>;

// @public (undocumented)
type PartialByKeys<T, K extends keyof T = keyof T> = MergeObject<Omit<T, K> & {
    [P in keyof T as P extends K ? P : never]?: T[P];
}>;

// @public (undocumented)
type PathKeys<T> = object extends T ? string : T extends readonly any[] ? Extract<keyof T, `${number}`> | SubKeys<T, Extract<keyof T, `${number}`>> : T extends object ? Extract<keyof T, string> | SubKeys<T, Extract<keyof T, string>> : never;

// @public (undocumented)
type PathParams<S extends string> = S extends `/${string}/:${infer Param}/${infer REST}` ? Param | PathParams<`/${REST}`> : S extends `${string}/:${infer Param}` ? Param : never;

// @public (undocumented)
type PathParamsObj<S extends string> = S extends `/${string}/:${infer Param}/${infer REST}` ? MergeObject<{
    [Key in Param]: string;
} & PathParamsObj<`/${REST}`>> : S extends `${string}/:${infer Param}` ? {
    [Key in Param]: string;
} : never;

// @public (undocumented)
type Permutation<T, U = T> = [T] extends [never] ? [] : U extends any ? [U, ...Permutation<Exclude<T, U>>] : [];

// @public (undocumented)
type Permutations<S extends string> = Combinations<StringToUnion<S>>;

// @public (undocumented)
type PickByType<T extends object, U> = {
    [Key in keyof T as T[Key] extends U ? Key : never]: T[Key];
};

// @public (undocumented)
type Placeholder<T extends string> = T extends `${string}{${infer P}}${infer REST}` ? P | Placeholder<REST> : never;

// @public (undocumented)
type PlusOne<T extends number, C extends unknown[] = []> = C['length'] extends T ? [...C, unknown]['length'] : PlusOne<T, [...C, unknown]>;

// @public (undocumented)
type Pop<T extends any[]> = T extends [...infer RT, infer _] ? RT : [];

// @public (undocumented)
export type Primitive = string | number | boolean | null;

// @public (undocumented)
function PromiseAll<T extends any[]>(values: readonly [...T]): Promise<{
    [Key in keyof T]: T[Key] extends Promise<infer V> ? V : T[Key];
}>;

// @public (undocumented)
type Properties<T extends {
    new (...args: any[]): any;
}> = keyof InstanceType<T>;

// @public (undocumented)
type PropPath<T, U> = U extends keyof T ? {
    [Key in U]: T[Key];
} : U extends `${infer P}.${infer RT}` ? P extends keyof T ? {
    [Key in P]: PropPath<T[Key], RT>;
} : never : never;

// @public (undocumented)
type PropType<T, Path extends string> = Path extends keyof T ? T[Path] : Path extends `${infer K}.${infer RT}` ? K extends keyof T ? PropType<T[K], RT> : unknown : unknown;

// @public (undocumented)
type Push<T extends any[], U> = [...T, U];

// @public (undocumented)
type ReadonlyKeys<T> = keyof {
    [Key in keyof T as Equal<Pick<T, Key>, Readonly<Pick<T, Key>>> extends true ? Key : never]: T[Key];
};

// @public (undocumented)
type Replace<S extends string, From extends string, To extends string> = From extends "" ? S : S extends `${infer A}${From}${infer B}` ? `${A}${To}${B}` : S;

// @public (undocumented)
type ReplaceAll<S extends string, From extends string, To extends string> = From extends "" ? S : S extends `${infer A}${From}${infer B}` ? `${A}${To}${ReplaceAll<B, From, To>}` : S;

// @public (undocumented)
type RequiredByKeys<T, K extends keyof T = keyof T> = MergeObject<Omit<T, K> & {
    [Key in keyof T as Key extends K ? Key : never]-?: T[Key];
}>;

// @public (undocumented)
type RequiredKeys<T extends Record<PropertyKey, any>> = keyof {
    [Key in keyof T as T[Key] extends Required<T>[Key] ? Key : never]: any;
};

// @public (undocumented)
type Reverse<T> = T extends [...infer H, infer T] ? [T, ...Reverse<H>] : [];

// @public (undocumented)
type Shift<T extends any[]> = T extends [infer _, ...infer REST] ? REST : [];

// Warning: (ae-forgotten-export) The symbol "SliceRightIgnoreSign" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "SliceLeftIgnoreSign" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type Slice<Arr extends readonly any[], Start extends number = 0, End extends number = Arr['length']> = `${Start}` extends `-${string}` ? SliceRightIgnoreSign<SliceLeftIgnoreSign<Arr, Start>, End> : SliceLeftIgnoreSign<SliceRightIgnoreSign<Arr, End>, Start>;

// @public (undocumented)
type SnakeCase<T, ACC extends string = ''> = T extends `${infer F}${infer REST}` ? Uppercase<F> extends F ? SnakeCase<REST, `${ACC}_${Lowercase<F>}`> : SnakeCase<REST, `${ACC}${F}`> : ACC;

// @public (undocumented)
type Space = " " | "\n" | "\t";

// @public (undocumented)
type Split<S extends string, SEP extends string> = Equal<S, string> extends true ? S[] : S extends `${infer P}${SEP}${infer RT}` ? [P, ...Split<RT, SEP>] : S extends "" ? SEP extends "" ? [] : [S] : [S];

// @public (undocumented)
type StartsWith<T extends string, U extends string> = T extends `${U}${string}` ? true : false;

// @public (undocumented)
type StringToUnion<S extends string> = S extends `${infer A}${infer B}` ? A | StringToUnion<B> : "";

// @public (undocumented)
type SubKeys<T, K extends string> = K extends keyof T ? `${K}.${PathKeys<T[K]>}` : never;

// @public (undocumented)
type Subsequence<T extends any[]> = T extends [infer F, ...infer RT] ? Subsequence<RT> | [F, ...Subsequence<RT>] : [];

// @beta
export function sum3(a: number, b: number, c: number): number;

// Warning: (ae-forgotten-export) The symbol "SumArr" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DigitArr" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type Sum_2<A extends string | number | bigint, B extends string | number | bigint> = SumArr<DigitArr<`${A}`>, DigitArr<`${B}`>>;

// @public (undocumented)
type ToNumber<S extends string, ACC extends unknown[] = []> = S extends `${number}` ? S extends `${ACC["length"]}` ? ACC["length"] : ToNumber<S, [...ACC, unknown]> : never;

// Warning: (ae-forgotten-export) The symbol "ArrayToPrimitive" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ObjectToPrimitive" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ValueToPrimitive" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type ToPrimitive<T extends Record<PropertyKey, any>> = {
    [Key in keyof T]: T[Key] extends any[] ? ArrayToPrimitive<T[Key]> : T[Key] extends object ? ObjectToPrimitive<T[Key]> : ValueToPrimitive<T[Key]>;
};

// @public
type ToUnion<T> = T extends any[] ? T[number] : T;

// @public
type Transpose<M extends number[][], R = M['length'] extends 0 ? [] : M[0]> = {
    [X in keyof R]: {
        [Y in keyof M]: X extends keyof M[Y] ? M[Y][X] : never;
    };
};

// @public (undocumented)
type Trim<S extends string> = S extends `${Space}${infer Word}` ? Trim<Word> : S extends `${infer Word}${Space}` ? Trim<Word> : S;

// @public (undocumented)
type TrimLeft<S extends string> = S extends `${Space}${infer RT}` ? TrimLeft<RT> : S;

// @public (undocumented)
type TrimRight<S extends string> = S extends `${infer Left}${Space}` ? TrimRight<Left> : S;

// @public (undocumented)
type Trunc<N extends number | string> = `${N}` extends `${infer NUM}.${infer _}` ? `${NUM}` : `${N}`;

// @public (undocumented)
type Try<A1, A2, Catch = never> = A1 extends A2 ? A1 : Catch;

// @public (undocumented)
type TupleToNestedObject<T extends any[], U> = T extends [
infer A extends string,
...infer REST
] ? {
    [Key in A]: TupleToNestedObject<REST, U>;
} : U;

// @public (undocumented)
type TupleToObject<T extends ReadonlyArray<string | number>> = {
    [Key in T[number]]: Key;
};

// @public (undocumented)
type TupleToUnion<T extends any[]> = T extends [infer F, ...infer RT] ? F | TupleToUnion<RT> : never;

// Warning: (ae-forgotten-export) The symbol "RecursiveAdd" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type TwoSum<T extends number[], U extends number> = T extends [
infer F extends number,
...infer RT extends number[]
] ? RecursiveAdd<F, RT, U> extends false ? TwoSum<RT, U> : true : false;

declare namespace types {
    export {
        All,
        AnyOf,
        ConstructTuple,
        Chunk,
        Enum,
        FindIndex,
        Fill,
        Filter,
        FilterOut,
        Flatten,
        First,
        Length,
        Last,
        LastIndexOf,
        Head,
        Shift,
        Join,
        NonEmptyArray,
        Includes,
        IndexOf,
        Push,
        Pop,
        Permutation,
        Reverse,
        Unshift,
        Subsequence,
        TupleToObject,
        Transpose,
        TupleToNestedObject,
        Unique,
        Without,
        Zip,
        DynamicParamsCurrying,
        Properties,
        ClassPublicKeys,
        defineStore,
        GetRes,
        join,
        AppendArgument,
        ExpectValidArgs,
        NoInfer,
        And,
        If,
        InorderTraversal,
        Fibonacci,
        Placeholder,
        OnPropChnagedMethods,
        IsPalindrome,
        TwoSum,
        UnionReplace,
        Multiply,
        Absolute,
        MinusOne,
        MinusN,
        PlusOne,
        GreaterThan,
        NumberRange,
        Trunc,
        Comparison,
        Negative,
        Comparator,
        getProp,
        Alike,
        Assign,
        AppendToObject,
        Exclusive,
        PropPath,
        DeepPick,
        CapitalizeNestObjectKeys,
        DeepReadonly,
        DeepPartial,
        DeepMutable,
        Diff,
        Get,
        GetRequired,
        GetOptional,
        KeyStartsWith,
        LookUp,
        PartialByKeys,
        MergeObject,
        Merge,
        PickByType,
        OmitByType,
        RequiredByKeys,
        MapTypes,
        Mutable,
        MutableKeys,
        ObjectEntries,
        ObjectFromEntries,
        GenNode,
        ObjectKeyPaths,
        OptionalKeys,
        RequiredKeys,
        IsRequiredKey,
        ReadonlyKeys,
        PathKeys,
        SubKeys,
        PropType,
        PromiseAll,
        ParseQueryString,
        PathParams,
        PathParamsObj,
        Slice,
        CamelizeWord,
        ConcatString,
        DropString,
        CapitalizeWords,
        LengthOfString,
        StartsWith,
        EndsWith,
        Combinations,
        Permutations,
        Replace,
        Trim,
        TrimLeft,
        ReplaceAll,
        Split,
        SnakeCase,
        TrimRight,
        Sum_2 as Sum,
        UnionToIntersectionFn,
        GetLastUnion,
        UnionToTuple,
        TupleToUnion,
        Brand,
        Valid,
        Try,
        Narrowable_2 as Narrowable,
        NarrowRaw,
        Debug,
        EnumLike,
        Expect,
        ExpectExtends,
        FalsyValues,
        Space,
        Camelize,
        DiscrimatedUnionToObject,
        KebabCase,
        CamelCase,
        StringToUnion,
        LowerLetterUnion,
        UpperLetterUnion,
        Equal,
        BEM,
        ToPrimitive,
        NumberToArray,
        BinaryToDecimal,
        ToUnion,
        Intersection,
        UnionToIntersection,
        ExtractValuesOfTuple,
        IsAny,
        NotAny,
        IsTuple,
        IsInteger,
        IsNever,
        ExpectTrue,
        ExpectFalse,
        IsTrue,
        IsFalse,
        isNegative,
        NumberToString,
        NotNil,
        IsNil,
        ObjectToUnion,
        ToNumber,
        Nullable,
        NeverByKeys,
        NotEqual,
        Maybe,
        MergeInsertions,
        XOR
    }
}
export { types }

// @public
type UnionReplace<T, U extends [any, any][]> = U extends [
infer F,
...infer RT extends [any, any][]
] ? F extends [infer ToBeReplaced, infer Replacer] ? UnionReplace<Exclude<T, ToBeReplaced> | Replacer, RT> : UnionReplace<T, RT> : T;

// @public (undocumented)
type UnionToIntersection<U> = (U extends any ? (x: U) => any : never) extends (x: infer R) => any ? R : never;

// @public (undocumented)
type UnionToIntersectionFn<U> = (U extends any ? (arg: () => U) => void : never) extends (arg: infer I) => void ? I : never;

// @public (undocumented)
type UnionToTuple<U, Last = GetLastUnion<U>> = [U] extends [never] ? [] : [...UnionToTuple<Exclude<U, Last>>, Last];

// @public (undocumented)
type Unique<T extends any[], ACC extends any[] = []> = T extends [
infer F,
...infer RT
] ? IndexOf<ACC, F> extends -1 ? Unique<RT, [...ACC, F]> : Unique<RT, ACC> : ACC;

// @public (undocumented)
type Unshift<T extends any[], U> = [U, ...T];

// @public (undocumented)
type UpperLetterUnion = Uppercase<LowerLetterUnion>;

// @public (undocumented)
type Valid<T> = Brand<T, "Valid">;

// @public (undocumented)
type Without<T extends any[], U extends any[] | any> = T extends [
infer F,
...infer RT
] ? U extends any[] ? F extends U[number] ? Without<RT, U> : [F, ...Without<RT, U>] : F extends U ? Without<RT, U> : [F, ...Without<RT, U>] : [];

// @public (undocumented)
type XOR<N extends boolean, M extends boolean> = [N, M] extends [
true,
true
] ? false : [N, M] extends [false, false] ? false : true;

// @public (undocumented)
type Zip<T, U> = T extends [infer F1, ...infer R1] ? U extends [infer F2, ...infer R2] ? [[F1, F2], ...Zip<R1, R2>] : [] : [];

// (No @packageDocumentation comment for this package)

```
